package org.danilopianini.gradle.git.hooks

import org.gradle.api.Plugin
import org.gradle.api.Task
import org.gradle.api.initialization.Settings
import org.gradle.api.tasks.TaskProvider
import org.gradle.kotlin.dsl.create
import java.io.File
import java.io.Serializable
import java.net.URL

/**
 * Just a template.
 */
open class GradleGitHooksPlugin : Plugin<Any> {
    override fun apply(settings: Any) {
        require (settings is Settings) {
            """
            ${this::class.simpleName} is not meant to be applied manually. It should be applied to settings.gradle.kts:
            plugins {
                id("org.danilopianini.gradle-pre-commit-git-hooks") version "<the version>"
            }
            gitHooks {
                ...
                createHooks()
            }
            """.trimIndent()
        }
        settings.extensions.create<GitHooksExtension>(GitHooksExtension.name, settings)
    }
}

open class GitHooksExtension(val settings: Settings) : Serializable {

    private var hooks: Map<String, String> = emptyMap()

    var path: File? = null
        get() =
            field ?: requireNotNull(generateSequence(settings.settingsDir) { it.parentFile }.find { it.isGitRoot() }) {
                "No git root could be found in ${settings.settingsDir.absolutePath} or any of its parent directories"
            }

    private inline fun <H : ScriptContext> hook(context: H, configuration: H.() -> Unit) {
        require(!hooks.containsKey(context.name)) {
            "it looks like the hook ${context.name} is being defined twice"
        }
        hooks = hooks + (context.name to context.apply(configuration).script)
    }

    fun hook(hookName: String, configuration: ScriptContext.() -> Unit) =
        hook(CommonScriptContext(hookName), configuration)

    fun preCommit(configuration: ScriptContext.() -> Unit) = hook("pre-commit", configuration)

    fun commitMsg(configuration: CommitMsgScriptContext.() -> Unit): Unit =
        hook(CommitMsgScriptContext(), configuration)

    fun createHooks(overwriteExisting: Boolean = false) {
        val root = requireNotNull(path?.takeIf { it.isGitRoot() }) {
            "${path?.absolutePath} is not a valid git root"
        }
        hooks.forEach { (name, script) ->
            val hook = File(root.absolutePath, "/.git/hooks/$name")
            if (!hook.exists()) {
                require(hook.createNewFile()) { "Cannot create file ${hook.absolutePath}" }
                hook.writeText(script)
            } else {
                val oldScript = hook.readText()
                if (oldScript != script) {
                    settings.gradle.rootProject.logger.warn(
                        """
                        |The hook $name exists, but its content differs from the one generated by the git-hooks plugin.
                        |
                        |Original content:
                        |${oldScript.withMargins()}
                        |
                        |New content:
                        |${script.withMargins()}
                        """.trimMargin()
                    )
                    if (overwriteExisting) {
                        settings.gradle.rootProject.logger.warn("Overwriting git hook $name")
                        hook.writeText(script)
                    }
                }
            }
        }
    }

    companion object {
        private const val serialVersionUID = 1L
        const val name: String = "gitHooks"

        private fun String.withMargins() = lines().joinToString(separator = "\n|", prefix = "|")

        private fun File.isGitRoot(): Boolean = listFiles()
            ?.any { folder ->
                folder.isDirectory &&
                    folder.name == ".git" &&
                    folder.listFiles()?.any { it.isDirectory && it.name == "hooks" } ?: false
            }
            ?: false
    }
}

interface ScriptContext {
    val name: String
    val script: String
    fun appendScript(script: () -> String)
    fun from(url: URL) = from("") { url.readText() }
    fun from(url: String) = from(URL(url))
    fun from(shebang: String? = "#!/usr/bin/env bash", script: () -> String)
    fun tasks(name: String, vararg otherNames: String, requireSuccess: Boolean = true) =
        tasks(name as Any, *otherNames, requireSuccess = requireSuccess)

    fun tasks(task: Task, vararg otherTasks: Task, requireSuccess: Boolean = true) =
        tasks(task as Any, *otherTasks, requireSuccess = requireSuccess)

    fun tasks(task: TaskProvider<*>, vararg otherTasks: TaskProvider<*>, requireSuccess: Boolean = true) =
        tasks(task as Any, *otherTasks, requireSuccess = requireSuccess)

    fun tasks(first: Any, vararg others: Any, requireSuccess: Boolean = true)
}

abstract class AbstractScriptContext : ScriptContext {

    final override fun tasks(first: Any, vararg others: Any, requireSuccess: Boolean) =
        processTasks(first, *others, requireSuccess = requireSuccess)

    protected abstract fun processTasks(vararg tasks: Any, requireSuccess: Boolean)

}

open class CommonScriptContext(override val name: String) : AbstractScriptContext() {
    final override var script: String = ""
        private set

    override fun appendScript(script: () -> String) {
        require(this.script.isNotEmpty()) {
            """
                An append was requested to an uninitialized script $name. Configure as follows, instead:
                gitHooks {
                    <your script block> {
                        from {
                            <heading, if any>
                        }
                        <remainder of your configuration>
                    }
                }
            """.trimIndent()
        }
        this.script += script() + '\n'
    }

    final override fun from(shebang: String?, script: () -> String) {
        require(this.script.isEmpty()) {
            """
            The $name git hook is being defined twice, and this is likely an error. Formerly:
            
            ${this.script}
            
            then:
            
            ${
                runCatching { script() }
                    .getOrElse { "Something whose evaluation this error:\n${it.stackTraceToString()}" }
            }
            """.trimIndent()
        }
        this.script = (shebang?.takeIf { it.isNotBlank() }?.let { "$it\n" } ?: "") + script()
    }

    final override fun processTasks(vararg tasks: Any, requireSuccess: Boolean) {
        val names = tasks.map { task ->
            when(task) {
                is String -> task
                is Task -> task.name
                is TaskProvider<*> -> task.name
                else -> throw IllegalStateException(
                    "Object '$task' with type '${task::class.simpleName}' cannot produce valid task names"
                )
            }
        }
        if (script.isEmpty()) {
            from { "" }
        }
        appendScript {
            """
            ${ if (requireSuccess) "set -e" else "" }
            ./gradlew ${names.joinToString(separator = " ")}
            ${ if (requireSuccess) "set +e" else "" }
            """.trimIndent()
        }
    }
}

class CommitMsgScriptContext : CommonScriptContext("commit-msg") {

    fun conventionalCommits(configuration: ConventionalCommitsContext.() -> Unit = { defaultTypes() }) {
        val types = object : ConventionalCommitsContext {
            override var types = super.types

            override fun types(otherTypes: Set<String>) {
                types = types + otherTypes
            }
        }.apply(configuration).types
        from("") {
            val script: URL = requireNotNull(Thread.currentThread().contextClassLoader.getResource(SCRIPT_PATH)) {
                "Unable to load $SCRIPT_PATH, this is likely a bug in the ${GitHooksExtension.name} plugin"
            }
            script.readText().replace("# INJECT_TYPES", types.joinToString(separator = " "))
        }
    }

    companion object {
        private val SCRIPT_PATH = "org/danilopianini/gradle/git/hooks/conventional-commit-message.sh"
    }
}

interface ConventionalCommitsContext {

    val types: Set<String> get() = baseTypes

    fun types(vararg otherTypes: String): Unit = types(otherTypes.toSet())

    fun types(otherTypes: Set<String>)

    fun defaultTypes() = types(defaultTypes)

    companion object {
        val baseTypes = setOf("fix", "feat")

        val defaultTypes: Set<String> = baseTypes + setOf(
            "build",
            "chore",
            "ci",
            "docs",
            "perf",
            "refactor",
            "revert",
            "style",
            "test",
        )
    }
}